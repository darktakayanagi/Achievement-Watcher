<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Achievements Overlay</title>
    <style>
      html,
      body {
        background: transparent;
        border-radius: 10px;
        margin: 0;
        padding: 0;
        overflow: hidden;
        user-select: none;
      }

      .scroll-container {
        max-height: 100vh;
        overflow-y: auto;
        scrollbar-width: none;
        -ms-overflow-style: none;
      }

      .scroll-container::-webkit-scrollbar {
        display: none;
      }

      table {
        color: white;
        border-collapse: collapse;
        background-color: rgba(0, 0, 0, 0.6);
        border-radius: 10px;
        overflow: hidden;
        width: 100%;
      }

      th {
        white-space: nowrap;
      }

      th,
      td {
        padding: 8px;
        border: 1px solid #555;
        text-align: center;
      }

      img {
        width: 50px;
        height: auto;
      }

      .drag {
        -webkit-app-region: drag;
      }
      .no-drag {
        -webkit-app-region: no-drag;
        pointer-events: auto;
        cursor: pointer; /* Optional: visually indicate interactivity */
      }
    </style>
  </head>
  <body>
    <div class="scroll-container">
      <table>
        <thead class="drag">
          <tr>
            <th>Icon</th>
            <th class="no-drag">Achievement</th>
            <th class="no-drag">Status</th>
          </tr>
        </thead>
        <tbody id="overlayTableBody"></tbody>
        <tfoot>
          <tr id="noConfigMessageRow" style="display: none">
            <td colspan="3" style="text-align: center; font-style: italic; color: #ccc">Select a config!</td>
          </tr>
        </tfoot>
      </table>
    </div>

    <script>
      let overlayLang = 'english';
      let currentConfigName = null;
      let isLoading = false;
      const headers = document.querySelectorAll('thead th');
      // Track sorting for status and achievement only
      let sortState = {
        status: null, // 1 = asc, -1 = desc, null = no sort
        achievement: null, // 1 = asc, -1 = desc, null = no sort
      };

      function updateHeaderIndicators() {
        headers.forEach((header, i) => {
          const text = header.textContent.replace(/[↑↓]/g, '').trim();
          header.textContent = text;

          if (i === 1 && sortState.achievement) {
            header.textContent += sortState.achievement === 1 ? ' ↑' : ' ↓';
          }

          if (i === 2 && sortState.status) {
            header.textContent += sortState.status === 1 ? ' ↑' : ' ↓';
          }
        });
      }

      function cycleSortState(current) {
        if (current === null) return 1;
        if (current === 1) return -1;
        return null;
      }

      function getSafeLocalizedText(input, lang = 'english') {
        if (!input) return 'Hidden';
        if (typeof input === 'string') return input.trim() || 'Hidden';
        if (typeof input === 'object') {
          return input[lang] || input.english || Object.values(input).find((v) => typeof v === 'string' && v.trim() !== '') || 'Hidden';
        }
        return 'Hidden';
      }

      function formatTimestamp(timestamp) {
        if (!timestamp) return 'N/A';
        const date = new Date(timestamp * 1000);
        return date.toLocaleString();
      }

      function sortAchievements(l) {
        return l.slice().sort((a, b) => {
          // Enforce status sorting first if active
          if (sortState.status) {
            const aStatus = a.Achieved ? 'a' : 'b';
            const bStatus = b.Achieved ? 'a' : 'b';
            if (aStatus < bStatus) return -1 * sortState.status;
            if (aStatus > bStatus) return 1 * sortState.status;
          }

          // Then achievement title sort
          if (sortState.achievement) {
            const aTitle = getSafeLocalizedText(a.displayName).toLowerCase();
            const bTitle = getSafeLocalizedText(b.displayName).toLowerCase();
            if (aTitle < bTitle) return -1 * sortState.achievement;
            if (aTitle > bTitle) return 1 * sortState.achievement;
          }

          return 0;
        });
      }

      async function loadTableData(game) {
        if (!game || isLoading) return;
        isLoading = true;

        const tableBody = document.querySelector('#overlayTableBody');
        const achievementsDataObj = game.achievements || game.achievement.list;
        const lang = overlayLang;

        if (!Array.isArray(achievementsDataObj)) {
          isLoading = false;
          return;
        }

        tableBody.innerHTML = '';
        const uniqueAchievements = new Set();

        headers.forEach((header, i) => {
          const text = header.textContent.replace(/[↑↓]/g, '').trim();
          header.textContent = text;

          if (i === 1 && sortState.achievement) {
            header.textContent += sortState.achievement === 1 ? ' ↑' : ' ↓';
          }
          if (i === 2 && sortState.status) {
            header.textContent += sortState.status === 1 ? ' ↑' : ' ↓';
          }

          if (i === 1)
            if (!headers[i].hasClick) {
              headers[i].addEventListener('click', () => {
                sortState.achievement = cycleSortState(sortState.achievement);
                loadTableData(game);
              });
              headers[i].hasClick = true;
            }
          if (i === 2)
            if (!headers[i].hasClick) {
              headers[i].addEventListener('click', () => {
                sortState.status = cycleSortState(sortState.status);
                loadTableData(game);
              });
              headers[i].hasClick = true;
            }
        });

        const sortedAchievements = sortAchievements(achievementsDataObj);
        sortedAchievements.forEach(async (achievement) => {
          if (!achievement.name || uniqueAchievements.has(achievement.name)) return;
          uniqueAchievements.add(achievement.name);

          const displayName = getSafeLocalizedText(achievement.displayName, lang);
          const description = getSafeLocalizedText(achievement.description, lang);
          const iconGray = achievement.icon_gray || achievement.icongray;
          const icon = achievement.icon || iconGray;

          let imagePath = await window.api.fetchIcon(iconGray, game.appid);
          let status = `<span style="color: red; font-weight: bold;">Locked</span>`;
          let earnedTimeText = '';
          let progressText = '';

          if (achievement.Achieved) {
            imagePath = await window.api.fetchIcon(icon, game.appid);
            status = `<span style="color: green; font-weight: bold;">Unlocked</span>`;
            earnedTimeText = `<br>${formatTimestamp(achievement.UnlockTime)}`;
          }

          if (typeof achievement.MaxProgress === 'number' && achievement.MaxProgress > 0) {
            progressText = `<br><span style="font-size: 0.85em; color: #888;">Progress: ${
              achievement.Achieved ? achievement.MaxProgress : achievement.CurProgress
            } / ${achievement.MaxProgress}</span>`;
          }

          const row = document.createElement('tr');
          row.innerHTML = `<td class="image"><img src="${imagePath}" alt="Icon" onerror="this.onerror=null; this.src='https://cdn-icons-png.flaticon.com/512/11455/11455431.png';" /></td>
                          <td class="displayName"><strong>${displayName}</strong><br><span class="description"><em>${description}</em>${progressText}</span></td>
                          <td class="status">${status} ${earnedTimeText}</td>
                        `;
          tableBody.appendChild(row);
        });

        currentConfigName = game;
        isLoading = false;
      }

      window.api.onOverlay((game) => {
        const tableBody = document.querySelector('#overlayTableBody');
        const messageRow = document.getElementById('noConfigMessageRow');

        if (!game) {
          tableBody.innerHTML = '';
          if (messageRow) messageRow.style.display = '';
          currentConfigName = null;
          return;
        }

        if (messageRow) messageRow.style.display = 'none';
        loadTableData(game);
      });

      window.api.onRefreshAchievementsTable(() => {
        if (currentConfigName) {
          loadTableData(currentConfigName);
        }
      });
    </script>
  </body>
</html>
